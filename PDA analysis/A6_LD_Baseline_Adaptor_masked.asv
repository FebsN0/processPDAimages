% Function to process and subtract the AFM LD images, this updated function
% uses the AFM IO image as a mask to select the background, thus a more
% precise fitting is possible.
% Check manually the processed image afterwards and compare with the AFM VD
% image!

function [Corrected_LD_Trace,AFM_Elab,Bk_iterative]=A6_LD_Baseline_Adaptor_masked(AFM_cropped_Images,AFM_height_IO,metadata.Alpha,avg_fc3,'Low');

    if(~isempty(varargin))&&(size(varargin,2)==1)
        if(iscell(varargin{1,1}))
            varargin=vertcat(varargin{:});
        end
    end
    p=inputParser();    %init instance of inputParser
    %Add default parameters. When call the function, use 'argName' as well you use 'LineStyle' in plot! And
    %then the values
    argName = 'Accuracy';
    defaultVal = 'Low';
    addOptional(p,argName,defaultVal, @(x) ismember(x,{'Low','Medium','High'}) );
    % validate and parse the inputs
    parse(p,input,varargin{:});
    clearvars argName defaultVal



    % extract data (lateral deflection Trace and Retrace, vertical deflection) and then mask (glass-PDA) elementXelement
    % ONLY in correspondence with the glass!
    Lateral_Trace_masked    = (AFM_cropped_Images(strcmpi({AFM_cropped_Images.Channel_name},'Lateral Deflection') & strcmpi({AFM_cropped_Images.Trace_type},'Trace')).Cropped_AFM_image)   %.*(~AFM_height_IO);
    Lateral_ReTrace_masked  = (AFM_cropped_Images(strcmpi({AFM_cropped_Images.Channel_name},'Lateral Deflection') & strcmpi({AFM_cropped_Images.Trace_type},'ReTrace')).Cropped_AFM_image) %.*(~AFM_height_IO);
    vertical_Trace   = (AFM_cropped_Images(strcmpi({AFM_cropped_Images.Channel_name},'Vertical Deflection') & strcmpi({AFM_cropped_Images.Trace_type},'Trace')).Cropped_AFM_image);
    vertical_ReTrace = (AFM_cropped_Images(strcmpi({AFM_cropped_Images.Channel_name},'Vertical Deflection') & strcmpi({AFM_cropped_Images.Trace_type},'ReTrace')).Cropped_AFM_image);

    % Calc Delta (offset loop) 
    Delta = (Lateral_Trace_masked + Lateral_ReTrace_masked) / 2;
    W = Lateral_Trace_masked - Delta;      
        
    % convert W into force (in Newton units) using alpha calibration factor and show results.
    force=W*alpha;
    % flip and rotate to have the start of scan line to left and the low setpoint to bottom)
    force=rot90(flipud(force));
    vertical_Trace=rot90(flipud(vertical_Trace));
    vertical_ReTrace=rot90(flipud(vertical_ReTrace));


    raw_data_LD_Trace 'Lateral Deflection' 'Trace'
    raw_data_LD_ReTrace 'Lateral Deflection' 'ReTrace'
    raw_data_VD_Trace 'Vertical Deflection' 'Trace'

    raw_data_LD_Trace_NO_Bl= Trace - ReTrace


    %Subtract the minimum of the image
    raw_data_LD_Trace_NO_Bl=minus(raw_data_LD_Trace_NO_Bl,min(min(raw_data_LD_Trace_NO_Bl)));
    
    figure,imshow(imadjust(raw_data_LD_Trace/max(max(raw_data_LD_Trace)))), colormap parula
    figure,imshow(imadjust(raw_data_VD_Trace/max(max(raw_data_VD_Trace)))), colormap parula
    figure,imshow(imadjust(raw_data_LD_Trace_NO_Bl/max(max(raw_data_LD_Trace_NO_Bl)))), colormap parula
    
    wb=waitbar(0/size(raw_data_LD_Trace_NO_Bl,1),sprintf('Removing Polynomial Baseline %.0f of %.0f',0,size(raw_data_LD_Trace_NO_Bl,1)),...
        'CreateCancelBtn','setappdata(gcbf,''canceling'',1)');
    setappdata(wb,'canceling',0);


% Polynomial baseline fitting (line by line)

warning ('off','all');
fit_decision_final=nan(size(raw_data_LD_Trace_NO_Bl,2),13);
Bk_iterative=zeros(size(raw_data_LD_Trace_NO_Bl,1),size(raw_data_LD_Trace_NO_Bl,2));
N_Cycluse_waitbar=size(raw_data_LD_Trace_NO_Bl,2);
limit=9;
fit_decision=zeros(3,limit);
for i=1:size(raw_data_LD_Trace_NO_Bl,2)
    waitbar(i/N_Cycluse_waitbar,wb,sprintf('Preparing for best fit ... Line %.0f Completeted  %2.1f %%',i,i/N_Cycluse_waitbar*100));

    
    % Mask to cut the PDA from the baseline fitting
    raw_data_LD_Trace_NO_Bl(AFM_height_IO==1)=5; %added on 19012020
    
    flag_signal_y=raw_data_LD_Trace_NO_Bl(:,i);
    flag_signal_x=(1:size(flag_signal_y,1))';
    [xData, yData] = prepareCurveData(flag_signal_x,flag_signal_y);

    if(size(xData,1)>2)
        opts = fitoptions( 'Method', 'LinearLeastSquares' );
        opts.Robust = 'LAR';
        
        for z=1:limit
            if (z==1)&&((strcmp(p.Results.Accuracy,'Low'))||(strcmp(p.Results.Accuracy,'Medium'))||(strcmp(p.Results.Accuracy,'High')))
                ft = fittype( 'poly1' );
            elseif (z==2)&&((strcmp(p.Results.Accuracy,'Low'))||(strcmp(p.Results.Accuracy,'Medium'))||(strcmp(p.Results.Accuracy,'High')))
                ft = fittype( 'poly2' );
            elseif (z==3)&&(strcmp(p.Results.Accuracy,'Medium')||(strcmp(p.Results.Accuracy,'High')))
                ft = fittype( 'poly3' );
            elseif (z==4)&&((strcmp(p.Results.Accuracy,'Low'))||(strcmp(p.Results.Accuracy,'Medium'))||(strcmp(p.Results.Accuracy,'High')))
                ft = fittype( 'poly4' );
            elseif (z==5)&&(strcmp(p.Results.Accuracy,'High'))
                ft = fittype( 'poly5' );
            elseif (z==6)&&(strcmp(p.Results.Accuracy,'High'))
                ft = fittype( 'poly6' );
            elseif (z==7)&&(strcmp(p.Results.Accuracy,'High'))
                ft = fittype( 'poly7' );
            elseif (z==8)&&(strcmp(p.Results.Accuracy,'High'))
                ft = fittype( 'poly8' );
            elseif (z==9)&&(strcmp(p.Results.Accuracy,'High'))
                ft = fittype( 'poly9' );
            end
            waitbar(i/N_Cycluse_waitbar,wb,sprintf('Observing %d° Ord Pol fit ... Line %.0f Completeted  %2.1f %%',z,i,i/N_Cycluse_waitbar*100));

            
            PDA=excludedata(xData, yData,'range',[-1 1]);
            [~, gof] = fit( xData, yData, ft,'Exclude', yData > 1 ); %added the exclusion on 19012020
            
            if(gof.adjrsquare<0)
                gof.adjrsquare=0.001;
            end
            
            if(~exist('fit_decision','var'))
                fit_decision(1,z)=abs(gof.sse)/gof.adjrsquare;
                fit_decision(2,z)=gof.sse;
                fit_decision(3,z)=gof.adjrsquare;
            else
                if (size(fit_decision,2)<limit+1)
                    fit_decision(1,z)=abs(gof.sse)/gof.adjrsquare;
                    fit_decision(2,z)=gof.sse;
                    fit_decision(3,z)=gof.adjrsquare;
                else
                    fit_decision(1,z)=(fit_decision(1,z)+(abs(gof.sse)/gof.adjrsquare))/2;
                    fit_decision(2,z)=gof.sse;
                    fit_decision(3,z)=gof.adjrsquare;
                end
            end
        end
        
        clearvars Ind
        [~,Ind]=nanmin(fit_decision(1,:));
        
        if (Ind==1)
            ft = fittype( 'poly1' );
        elseif (Ind==2)
            ft = fittype( 'poly2' );
        elseif (Ind==3)
            ft = fittype( 'poly3' );
        elseif (Ind==4)
            ft = fittype( 'poly4' );
        elseif (Ind==5)
            ft = fittype( 'poly5' );
        elseif (Ind==6)
            ft = fittype( 'poly6' );
        elseif (Ind==7)
            ft = fittype( 'poly7' );
        elseif (Ind==8)
            ft = fittype( 'poly8' );
        elseif (Ind==9)
            ft = fittype( 'poly9' );
        end
        waitbar(i/N_Cycluse_waitbar,wb,sprintf('Applying %d° Ord Pol fit ... Line %.0f Completeted  %2.1f %%',Ind,i,i/N_Cycluse_waitbar*100));

        fit_decision_final(i,1)=Ind;
        fit_decision_final(i,2)=fit_decision(2,Ind);
        fit_decision_final(i,3)=fit_decision(3,Ind);
        [fitresult, ~] = fit( xData, yData, ft, 'Exclude', yData > 1 );
        
        x=1:size(raw_data_LD_Trace_NO_Bl,1);
    else
        Ind=0;
    end

    if(Ind==1)
        Bk_iterative(:,i)=fitresult.p1*x+fitresult.p2;
        fit_decision_final(i,4)=fitresult.p1;
        fit_decision_final(i,5)=fitresult.p2;
    elseif(Ind==2)
        Bk_iterative(:,i)=fitresult.p1*(x).^2+fitresult.p2*x+fitresult.p3;
        fit_decision_final(i,4)=fitresult.p1;
        fit_decision_final(i,5)=fitresult.p2;
        fit_decision_final(i,6)=fitresult.p3;
    elseif(Ind==3)
        Bk_iterative(:,i)=fitresult.p1*(x).^3+fitresult.p2*(x).^2+fitresult.p3*x+fitresult.p4;
        fit_decision_final(i,4)=fitresult.p1;
        fit_decision_final(i,5)=fitresult.p2;
        fit_decision_final(i,6)=fitresult.p3;
        fit_decision_final(i,7)=fitresult.p4;
    elseif(Ind==4)
        Bk_iterative(:,i)=fitresult.p1*(x).^4+fitresult.p2*(x).^3+fitresult.p3*(x).^2+fitresult.p4*x+fitresult.p5;
        fit_decision_final(i,4)=fitresult.p1;
        fit_decision_final(i,5)=fitresult.p2;
        fit_decision_final(i,6)=fitresult.p3;
        fit_decision_final(i,7)=fitresult.p4;
        fit_decision_final(i,8)=fitresult.p5;
    elseif(Ind==5)
        Bk_iterative(:,i)=fitresult.p1*(x).^5+fitresult.p2*(x).^4+fitresult.p3*(x).^3+fitresult.p4*(x).^2+fitresult.p5*x+fitresult.p6;
        fit_decision_final(i,4)=fitresult.p1;
        fit_decision_final(i,5)=fitresult.p2;
        fit_decision_final(i,6)=fitresult.p3;
        fit_decision_final(i,7)=fitresult.p4;
        fit_decision_final(i,8)=fitresult.p5;
        fit_decision_final(i,9)=fitresult.p6;
    elseif(Ind==6)
        Bk_iterative(:,i)=fitresult.p1*(x).^6+fitresult.p2*(x).^5+fitresult.p3*(x).^4+fitresult.p4*(x).^3+fitresult.p5*(x).^2+fitresult.p6*x+fitresult.p7;
        fit_decision_final(i,4)=fitresult.p1;
        fit_decision_final(i,5)=fitresult.p2;
        fit_decision_final(i,6)=fitresult.p3;
        fit_decision_final(i,7)=fitresult.p4;
        fit_decision_final(i,8)=fitresult.p5;
        fit_decision_final(i,9)=fitresult.p6;
        fit_decision_final(i,10)=fitresult.p7;
    elseif(Ind==7)
        Bk_iterative(:,i)=fitresult.p1*(x).^7+fitresult.p2*(x).^6+fitresult.p3*(x).^5+fitresult.p4*(x).^4+fitresult.p5*(x).^3+fitresult.p6*(x).^2+fitresult.p7*x+fitresult.p8;
        fit_decision_final(i,4)=fitresult.p1;
        fit_decision_final(i,5)=fitresult.p2;
        fit_decision_final(i,6)=fitresult.p3;
        fit_decision_final(i,7)=fitresult.p4;
        fit_decision_final(i,8)=fitresult.p5;
        fit_decision_final(i,9)=fitresult.p6;
        fit_decision_final(i,10)=fitresult.p7;
        fit_decision_final(i,11)=fitresult.p8;
    elseif(Ind==8)
        Bk_iterative(:,i)=fitresult.p1*(x).^8+fitresult.p2*(x).^7+fitresult.p3*(x).^6+fitresult.p4*(x).^5+fitresult.p5*(x).^4+fitresult.p6*(x).^3+fitresult.p7*(x).^2+fitresult.p8*x+fitresult.p9;
        fit_decision_final(i,4)=fitresult.p1;
        fit_decision_final(i,5)=fitresult.p2;
        fit_decision_final(i,6)=fitresult.p3;
        fit_decision_final(i,7)=fitresult.p4;
        fit_decision_final(i,8)=fitresult.p5;
        fit_decision_final(i,9)=fitresult.p6;
        fit_decision_final(i,10)=fitresult.p7;
        fit_decision_final(i,11)=fitresult.p8;
        fit_decision_final(i,12)=fitresult.p9;
    elseif(Ind==9)
        Bk_iterative(:,i)=fitresult.p1*(x).^9+fitresult.p2*(x).^8+fitresult.p3*(x).^7+fitresult.p4*(x).^6+fitresult.p5*(x).^5+fitresult.p6*(x).^4+fitresult.p7*(x).^3+fitresult.p8*(x).^2+fitresult.p9*x+fitresult.p10;
        fit_decision_final(i,4)=fitresult.p1;
        fit_decision_final(i,5)=fitresult.p2;
        fit_decision_final(i,6)=fitresult.p3;
        fit_decision_final(i,7)=fitresult.p4;
        fit_decision_final(i,8)=fitresult.p5;
        fit_decision_final(i,9)=fitresult.p6;
        fit_decision_final(i,10)=fitresult.p7;
        fit_decision_final(i,11)=fitresult.p8;
        fit_decision_final(i,12)=fitresult.p9;
        fit_decision_final(i,13)=fitresult.p10;
    end
    if getappdata(wb,'canceling')
        break
    end
end

to_avg=find(fit_decision_final(:,3)<0.95);
if(exist('to_avg','var'))
    for i=1:size(to_avg,1)-1
        if(to_avg(i,1)~=1)
            Bk_iterative(:,to_avg(i,1))=(Bk_iterative(:,to_avg(i,1)-1)+Bk_iterative(:,to_avg(i,1)+1))/2;
        elseif(to_avg(i,1)==1)
            Bk_iterative(:,to_avg(i,1))=Bk_iterative(:,to_avg(i,1)+1);
        elseif(to_avg(i,1)==size(Bk_iterative,2))
            Bk_iterative(:,to_avg(i,1))=Bk_iterative(:,to_avg(i,1)-1);
        end
    end
end
% The fitted backround:
% Bk_iterative_visible_data=imadjust(Bk_iterative);
Bk_iterative_visible_data=Bk_iterative/max(max(Bk_iterative));
Bk_iterative_visible_data=imadjust(Bk_iterative_visible_data);
figure;title('Usable Partial of Image'),imshow(Bk_iterative_visible_data),colormap parula

% To remove the minimum of the image and then the background (friction on glass should be zero afterwards):
raw_data_LD_Trace_NO_Bl=minus(raw_data_LD_Trace,min(min(raw_data_LD_Trace)));
raw_data_LD_Trace_NO_BK=minus(raw_data_LD_Trace_NO_Bl,Bk_iterative);
figure,imshow(imadjust(raw_data_LD_Trace_NO_BK/max(max(raw_data_LD_Trace_NO_BK)))), colormap parula
Baseline_Friction=times(raw_data_VD_Trace,avg_fc);
raw_data_LD_Trace_Adapt_N=times(raw_data_LD_Trace_NO_BK,Alpha);

% To readd the baseline friction, to obtain the processed image:
Corrected_LD_Trace=plus(raw_data_LD_Trace_Adapt_N,Baseline_Friction);
figure,imshow(imadjust(Corrected_LD_Trace/max(max(Corrected_LD_Trace)))), colormap parula

AFM_Elab=AFM_Cropped;
AFM_Elab(POI).Cropped_AFM_image=Corrected_LD_Trace;

    if(exist('wb','var'))
        delete (wb)
    end

end